---
title: "Picasso Triggerfish Reflectance Analysis Demo"
author: "Grok (xAI)"
date: "March 20, 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(signal)  # For derivatives
library(hyperSpec)  # For spectral angle (simplified ACE)
library(stats)  # For PCA and statistical tests
```

## Overview
This demo analyzes simulated reflectance data for four color patches (White, Black, Orange, Blue) in Picasso triggerfish (*Rhinecanthus aculeatus*) across 400-800 nm for five individuals with three repeated measures per patch. It replicates figures from Kolmann et al. (2021)—Figures 3, 5, 6, and 7—and explores alternative methods to distinguish patches within individuals. The data includes measurement error (SD = 2%), inter-individual variation (±10% amplitude, ±20 nm peak shift), and one faded individual (30% reduced reflectance).

## Data Simulation
The reflectance data was simulated with biologically realistic curves:
- **White**: Structural, high reflectance (~70-90%) with a broad peak at 500 nm.
- **Black**: Pigmented, low reflectance (~10%) across all wavelengths.
- **Orange**: Pigmented, peak at 620 nm (~90%).
- **Blue**: Pigmented, peak at 470 nm (~85%).

## Load Data
```{r load-data}
data <- read.csv("Picasso_Triggerfish_Reflectance.csv")
patches <- unique(data$Patch)  # Define patches variable
n_ind <- length(unique(data$Individual))  # Define number of individuals
head(data)
```

The dataset includes columns: `Individual`, `Patch`, `Replicate`, `Wavelength`, and `Reflectance`.

## Figure 3: Comparative Spectral Signatures
```{r fig3}
fig3_data <- data %>%
  group_by(Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), SD = sd(Reflectance), .groups = "drop")

ggplot(fig3_data, aes(x = Wavelength, y = Mean, color = Patch)) +
  geom_line() +
  geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), alpha = 0.2, linetype = 0) +
  labs(title = "Figure 3: Comparative Spectral Signatures",
       x = "Wavelength (nm)", y = "Reflectance (%)",
       caption = "Mean reflectance per patch across all individuals and replicates. Within-patch variation (measurement error and individual differences) is captured by SD bands. Between-individual variation is averaged out.") +
  theme_minimal()
```

**Legend**: This figure shows the mean reflectance profile for each patch, averaging across all individuals and their three replicates. Within-patch variation includes measurement error (SD = 2% per replicate) and between-individual differences (e.g., amplitude and peak shifts), visualized as standard deviation (SD) bands. Between-individual variation is collapsed into the mean, highlighting patch-specific spectral shapes.

## Figure 5: First Derivatives
```{r fig5}
fig5_data <- fig3_data %>%
  group_by(Patch) %>%
  arrange(Wavelength) %>%
  mutate(Deriv = c(NA, diff(Mean) / diff(Wavelength)[1])) %>%
  ungroup()

ggplot(fig5_data, aes(x = Wavelength, y = Deriv, color = Patch)) +
  geom_line() +
  labs(title = "Figure 5: First Derivative of Spectral Signatures",
       x = "Wavelength (nm)", y = "dR/dλ",
       caption = "First derivative of mean reflectance per patch. Within-patch variation is averaged, focusing on rate of change across wavelengths. Between-individual variation is not shown as it's collapsed into the mean.") +
  theme_minimal()
```

**Legend**: The first derivative of mean reflectance per patch highlights regions of rapid change. Within-patch variation (replicate error and individual differences) is averaged into the mean reflectance before differentiation, so this figure focuses on patch-specific trends rather than individual-level variation. Between-individual differences are not directly visible, as the derivative is computed from the aggregated mean.

## Figure 6: Intraspecific Variation
```{r fig6}
fig6_plots <- lapply(patches, function(p) {
  p_data <- subset(data, Patch == p)
  mean_data <- aggregate(Reflectance ~ Wavelength, data = p_data, FUN = mean)
  
  ggplot() +
    geom_line(data = p_data, 
              aes(x = Wavelength, y = Reflectance, group = interaction(Individual, Replicate)),
              alpha = 0.3) +
    geom_line(data = mean_data,
              aes(x = Wavelength, y = Reflectance),
              color = "red", size = 1) +
    labs(title = paste("Patch:", p),
         x = "Wavelength (nm)", y = "Reflectance (%)",
         caption = "All replicates (thin lines) show within-individual variation (measurement error, SD = 2%) and between-individual variation (e.g., amplitude, peak shifts). Red line is the patch mean across all individuals.") +
    theme_minimal()
})

grid.arrange(grobs = fig6_plots, ncol = 2)
```

**Legend**: Each panel displays reflectance curves for a single patch across all individuals and replicates (thin lines), with the mean in red. Within-individual variation is the spread among the three replicates per individual (measurement error, SD = 2%). Between-individual variation is evident in differences in amplitude and peak positions across individuals (e.g., one faded individual has lower reflectance). Within-patch variation combines both, captured by the spread of all lines, while the red mean averages across individuals to show the typical patch profile.

## Figure 7: Adaptive Coherence Estimator (ACE)
### Equations
Kolmann et al. (2021) use ACE for spectral matching, with two key equations:

- **Equation 1: Spectral Angle (α)**  
  Measures similarity between test spectrum \(\mathbf{x}\) (individual mean) and target spectrum \(\mathbf{S}\) (patch mean):
  \[
  \alpha = \cos^{-1} \left( \frac{\mathbf{x} \cdot \mathbf{S}}{\|\mathbf{x}\| \|\mathbf{S}\|} \right)
  \]
  Where \(\mathbf{x} \cdot \mathbf{S}\) is the dot product, and \(\|\mathbf{x}\|\) and \(\|\mathbf{S}\|\) are Euclidean norms. Lower angles indicate greater similarity.

- **Equation 2: ACE Detection Statistic**  
  Incorporates background covariance \(\Sigma_b\):
  \[
  D_{ACE} = \frac{(\mathbf{S}^T \Sigma_b^{-1} \mathbf{x})^2}{(\mathbf{S}^T \Sigma_b^{-1} \mathbf{S})(\mathbf{x}^T \Sigma_b^{-1} \mathbf{x})}
  \]
  Values closer to 1 indicate a match, accounting for background variability.

### Analysis
We calculate spectral angles between each individual's mean spectrum and the overall mean per patch, simplifying ACE by omitting \(\Sigma_b\).

```{r fig7}
mean_spectra <- data %>%
  group_by(Individual, Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), .groups = "drop") %>%
  pivot_wider(names_from = Wavelength, values_from = Mean)

patch_means <- data %>%
  group_by(Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), .groups = "drop") %>%
  pivot_wider(names_from = Wavelength, values_from = Mean)

spectral_angle <- function(x, s) {
  dot <- sum(x * s, na.rm = TRUE)
  norm_x <- sqrt(sum(x^2, na.rm = TRUE))
  norm_s <- sqrt(sum(s^2, na.rm = TRUE))
  acos(dot / (norm_x * norm_s)) * 180 / pi  # Degrees
}

ace_data <- data.frame(
  Individual = rep(unique(data$Individual), each = length(patches)),
  Patch = rep(patches, n_ind),
  Angle = numeric(n_ind * length(patches))
)

for (i in 1:nrow(ace_data)) {
  ind <- ace_data$Individual[i]
  patch <- ace_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  ace_data$Angle[i] <- spectral_angle(x, s)
}

ggplot(ace_data, aes(x = Patch, y = Individual, fill = Angle)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Spectral Angle (°)") +
  labs(title = "Figure 7: ACE Spectral Matching",
       x = "Target Patch", y = "Test Individual",
       caption = "Spectral angles between individual means and patch means. Within-individual variation is averaged per individual. Between-individual variation drives angle differences (e.g., faded individual has higher angles).") +
  theme_minimal()
```

### Detailed ACE Explanation
- **How ACE Uses Spectral Angle**: In Kolmann et al. (2021), ACE matches a test spectrum (\(\mathbf{x}\)) to a known target (\(\mathbf{S}\)) by considering both similarity (via spectral angle, Eq. 1) and background variability (via \(\Sigma_b\), Eq. 2). The spectral angle measures the cosine similarity between vectors, ignoring amplitude differences and focusing on shape. Equation 2 adjusts this by weighting against background covariance, enhancing detection in noisy data.
- **Simplifications**: Here, we use only Equation 1 (spectral angle) due to the small dataset (5 individuals, 4 patches). Calculating \(\Sigma_b\) (background covariance) requires a larger sample to be meaningful, so we omit Equation 2's full ACE statistic. This simplification assumes the patch mean (\(\mathbf{S}\)) is the target, and individual deviations (e.g., fading) increase the angle. For real data with more samples, \(\Sigma_b\) would be computed from all non-target spectra to improve specificity.
- **Does ACE Work Here?**: Yes, but with caveats. With only 5 individuals and 20 spectra (5 × 4 patches), the dataset is small for full ACE (which thrives on larger, noisier datasets). The spectral angle alone effectively highlights variation (e.g., the faded individual), but lacks the robustness of \(\Sigma_b\)-adjusted ACE. For your real data, with potentially more individuals, full ACE would be feasible and more powerful.

## Alternative Methods for Patch Differentiation

Given your focus on distinguishing color patches within fish, here are three alternatives to ACE, using mean spectra per patch per individual.

### Alternative 1: Euclidean Distance
Measures absolute spectral difference, including amplitude.

```{r alt1-euclidean}
euclidean_dist <- function(x, s) {
  sqrt(sum((x - s)^2, na.rm = TRUE))
}

euclid_data <- ace_data  # Reuse structure
for (i in 1:nrow(euclid_data)) {
  ind <- euclid_data$Individual[i]
  patch <- euclid_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  euclid_data$Angle[i] <- euclidean_dist(x, s)  # Rename 'Angle' to 'Distance'
}
colnames(euclid_data)[3] <- "Distance"

ggplot(euclid_data, aes(x = Patch, y = Individual, fill = Distance)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Euclidean Distance") +
  labs(title = "Alternative 1: Euclidean Distance",
       x = "Target Patch", y = "Test Individual",
       caption = "Euclidean distance between individual means and patch means. Within-individual variation is averaged; between-individual variation (e.g., fading) increases distance.") +
  theme_minimal()
```

**Explanation**: Euclidean distance captures both shape and amplitude differences, making it sensitive to fading (higher distances). It's simpler than ACE but lacks background adjustment.

### Alternative 2: Principal Component Analysis (PCA)
Reduces dimensionality to compare patches.

```{r alt2-pca}
spectra_matrix <- mean_spectra[, -(1:2)] %>% as.matrix()
pca_result <- prcomp(spectra_matrix, scale. = TRUE)
pca_data <- as.data.frame(pca_result$x) %>%
  mutate(Individual = mean_spectra$Individual, Patch = mean_spectra$Patch)

ggplot(pca_data, aes(x = PC1, y = PC2, color = Patch, shape = Individual)) +
  geom_point(size = 3) +
  labs(title = "Alternative 2: PCA of Spectral Signatures",
       x = "PC1", y = "PC2",
       caption = "PCA on mean spectra per patch per individual. Within-individual variation is averaged; between-individual and within-fish patch differences drive separation.") +
  theme_minimal()
```

**Explanation**: PCA projects 81-band spectra into principal components (PC1, PC2 explain most variance). Patches cluster by spectral similarity; between-individual variation (e.g., fading) scatters points within clusters.

### Alternative 3: Mahalanobis Distance
Measures distance adjusted for covariance.

```{r alt3-mahalanobis}
mahalanobis_dist <- function(x, mean_vec, cov_mat, lambda = 0.1) {
  # Add regularization to covariance matrix
  n <- nrow(cov_mat)
  regularized_cov <- cov_mat + lambda * diag(n)
  diff <- x - mean_vec
  sqrt(t(diff) %*% solve(regularized_cov) %*% diff)
}

mahal_data <- ace_data
cov_mat <- cov(spectra_matrix)  # Covariance of all spectra
for (i in 1:nrow(mahal_data)) {
  ind <- mahal_data$Individual[i]
  patch <- mahal_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  mahal_data$Angle[i] <- mahalanobis_dist(x, s, cov_mat)
}
colnames(mahal_data)[3] <- "Distance"

ggplot(mahal_data, aes(x = Patch, y = Individual, fill = Distance)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Mahalanobis Distance") +
  labs(title = "Alternative 3: Mahalanobis Distance",
       x = "Target Patch", y = "Test Individual",
       caption = "Mahalanobis distance between individual means and patch means, using regularized covariance. Within-individual variation is averaged; between-individual variation affects distances.") +
  theme_minimal()
```

**Explanation**: Mahalanobis distance accounts for spectral covariance, similar to ACE's \(\Sigma_b\), but compares to a single mean. It's robust to correlated bands but requires sufficient spectra (here, limited by 20 means).

## Statistical Index for Patch Differences
To test if patches are statistically distinct within fish, compute spectral angles per individual and use ANOVA (or Kruskal-Wallis if non-normal) with pairwise comparisons.

```{r patch-stats}
# Create all possible patch pairs
patch_pairs <- combn(patches, 2, paste, collapse = " vs. ")

# Calculate angles between all patch pairs for each individual
angle_data <- data.frame()
for (ind in unique(data$Individual)) {
  for (i in 1:(length(patches)-1)) {
    for (j in (i+1):length(patches)) {
      x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patches[i], -(1:2)])
      s <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patches[j], -(1:2)])
      angle <- spectral_angle(x, s)
      angle_data <- rbind(angle_data, 
                         data.frame(Individual = ind,
                                  Patch_Pair = paste(patches[i], "vs.", patches[j]),
                                  Angle = angle))
    }
  }
}

# Kruskal-Wallis test (non-parametric)
kw_test <- kruskal.test(Angle ~ Patch_Pair, data = angle_data)
print(kw_test)

# Pairwise Wilcoxon tests
pairwise <- pairwise.wilcox.test(angle_data$Angle, angle_data$Patch_Pair, p.adjust.method = "BH")
print(pairwise)

ggplot(angle_data, aes(x = Patch_Pair, y = Angle)) +
  geom_boxplot() +
  labs(title = "Spectral Angles Between Patch Pairs",
       x = "Patch Pair", y = "Spectral Angle (°)",
       caption = "Boxplots of spectral angles between patch pairs within individuals. Kruskal-Wallis test assesses overall differences; pairwise p-values indicate specific distinctions.") +
  theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Summary of Discussion on ULTRIS X50 and ACE

The ULTRIS X50 (400-800 nm, ~101 bands at 4 nm binning) increases spectral dimensions from 81 to 101, raising the minimum spectra for full ACE from 162-405 to 202-505. Sampling 3 patches per color (12 total) per individual with 3 replicates yields 36 spectra per fish; 20 individuals (720 spectra) suffice for ACE, prioritizing individuals over patches. The data cube's pixel richness allows averaging (e.g., 10,000 pixels per patch), reducing noise and enabling spectral angle alone to distinguish patches within fish, though ACE excels for subtle signals. Focus on patch differentiation supports spectral angle or alternatives (Euclidean, PCA, Mahalanobis), with statistical tests (e.g., Kruskal-Wallis, pairwise p-values) confirming distinctions.

## Final Interpretation
- **ACE**: Detects patch differences but is limited here; alternatives suffice.
- **Euclidean**: Highlights amplitude shifts (e.g., fading).
- **PCA**: Visualizes patch clustering within fish.
- **Mahalanobis**: Adjusts for covariance, robust for patch separation.
- **Stats**: Pairwise p-values confirm if patches are distinct within individuals.

This template is ready for your real data—replace the CSV and adjust as needed.
