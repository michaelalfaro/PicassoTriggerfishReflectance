---
title: "Picasso Triggerfish Reflectance Analysis Demo"
author: "Grok (xAI)"
date: "March 20, 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(signal)  # For derivatives
library(hyperSpec)  # For spectral angle (simplified ACE)
library(stats)  # For PCA and statistical tests
```

## Overview
This demo explores simulated reflectance data for four color patches (White, Black, Orange, Blue) on Picasso triggerfish (*Rhinecanthus aculeatus*) across 400-800 nm, with five fish, each measured three times per patch. We're mimicking analyses from Kolmann et al. (2021) to see if we can tell these patches apart within a fish—like detectives comparing color fingerprints! The data has some noise (measurement error, SD = 2%), differences between fish (±10% brightness, ±20 nm shifts), and one fish is faded (30% dimmer) to test our methods.

## Data Simulation
We made fake data that looks real:
- **White**: Bright (~70-90%), peaks around 500 nm (blue-green).
- **Black**: Dull (~10%), flat across wavelengths.
- **Orange**: Bright (~90%), peaks at 620 nm (orange-red).
- **Blue**: Bright (~85%), peaks at 470 nm (blue).

Think of these as "color recipes" we expect on a triggerfish, with a bit of randomness to mimic nature.

## Load Data
```{r load-data}
data <- read.csv("Picasso_Triggerfish_Reflectance.csv")
patches <- unique(data$Patch)  # Our four colors
n_ind <- length(unique(data$Individual))  # Five fish
head(data)
```

**Breakdown**:
- **What's Happening**: We load a table with columns: `Individual` (fish ID), `Patch` (color), `Replicate` (measurement number), `Wavelength` (400-800 nm), and `Reflectance` (brightness %).
- **Data Structure**: A long list—9720 rows (5 fish × 4 patches × 3 replicates × 81 wavelengths). Each row is one data point.
- **Illustration**: Imagine a spreadsheet where each fish gets a block of rows, split by color, then by replicate, with columns for every 5 nm step from 400 to 800.
- **Why It Matters**: This structure lets us slice and dice data flexibly—by fish, color, or wavelength—for all our analyses.

## Figure 3: Comparative Spectral Signatures
Let's see the average "color fingerprint" for each patch.

```{r fig3}
fig3_data <- data %>%
  group_by(Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), SD = sd(Reflectance), .groups = "drop")

ggplot(fig3_data, aes(x = Wavelength, y = Mean, color = Patch)) +
  geom_line() +
  geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), alpha = 0.2, linetype = 0) +
  labs(title = "Figure 3: Comparative Spectral Signatures",
       x = "Wavelength (nm)", y = "Reflectance (%)",
       caption = "Mean reflectance per patch across all individuals and replicates. Within-patch variation (measurement error and individual differences) is captured by SD bands. Between-individual variation is averaged out.") +
  theme_minimal()
```

**Breakdown**:
- **Step 1: Grouping and Averaging**
  - **Code**: `group_by(Patch, Wavelength) %>% summarise(Mean = mean(Reflectance), SD = sd(Reflectance))`
  - **What**: For each color and wavelength, we average all 15 measurements (5 fish × 3 replicates) and calculate the wiggle (standard deviation).
  - **Structure**: From 9720 rows to 324 (4 patches × 81 wavelengths), with columns: `Patch`, `Wavelength`, `Mean`, `SD`.
  - **Illustration**: Picture a smaller table—each row is a color at a wavelength, with a mean and SD column. Draw four lines (one per color) with shaded bands around them.
  - **Why**: This simplifies our messy data into smooth curves we can compare, showing typical patch "fingerprints."

- **Step 2: Plotting**
  - **Code**: `ggplot(...) + geom_line() + geom_ribbon(...)`
  - **What**: Plot wavelength (x) vs. mean reflectance (y), with colored lines for each patch and shaded bands for SD.
  - **Why**: Visualizes how patches differ across the spectrum—key for our "are they distinguishable?" question.

- **Expectations**:
  - **Distinguishable Patches**: Curves spread apart (e.g., Blue peaks at 470 nm, Orange at 620 nm), with little SD overlap—clear "fingerprints."
  - **Not Distinguishable**: Curves overlap a lot, SD bands blur together—colors look too similar.

## Figure 5: First Derivatives
Now, let's zoom into how fast these "fingerprints" change.

```{r fig5}
fig5_data <- fig3_data %>%
  group_by(Patch) %>%
  arrange(Wavelength) %>%
  mutate(Deriv = c(NA, diff(Mean) / diff(Wavelength)[1])) %>%
  ungroup()

ggplot(fig5_data, aes(x = Wavelength, y = Deriv, color = Patch)) +
  geom_line() +
  labs(title = "Figure 5: First Derivative of Spectral Signatures",
       x = "Wavelength (nm)", y = "dR/dλ",
       caption = "First derivative of mean reflectance per patch. Within-patch variation is averaged, focusing on rate of change across wavelengths. Between-individual variation is not shown as it's collapsed into the mean.") +
  theme_minimal()
```

**Breakdown**:
- **Step 1: Calculate Derivative**
  - **Code**: `mutate(Deriv = c(NA, diff(Mean) / diff(Wavelength)[1]))`
  - **What**: For each patch, subtract each mean from the next, divide by 5 nm (wavelength step), to get the slope. First point is NA (no prior value).
  - **Structure**: Still 324 rows, adds `Deriv` column (slope at each wavelength).
  - **Illustration**: Sketch the Figure 3 curves, then draw tangent lines at points—steep slopes mean big `Deriv` values.
  - **Why**: Highlights where curves change fastest (e.g., peaks), helping spot unique patch features.

- **Step 2: Plotting**
  - **Code**: `ggplot(...) + geom_line()`
  - **What**: Plot wavelength vs. slope, colored by patch.
  - **Why**: Shows patch-specific "action zones"—where they stand out.

- **Expectations**:
  - **Distinguishable**: Sharp, distinct peaks/dips (e.g., Blue at ~470 nm, Orange at ~620 nm)—different change patterns.
  - **Not Distinguishable**: Slopes overlap or flatline—no clear "action zones."

## Figure 6: Intraspecific Variation
Let's peek at how much fish differ within each patch.

```{r fig6}
fig6_plots <- lapply(patches, function(p) {
  p_data <- subset(data, Patch == p)
  mean_data <- aggregate(Reflectance ~ Wavelength, data = p_data, FUN = mean)
  
  ggplot() +
    geom_line(data = p_data, 
              aes(x = Wavelength, y = Reflectance, group = interaction(Individual, Replicate)),
              alpha = 0.3) +
    geom_line(data = mean_data,
              aes(x = Wavelength, y = Reflectance),
              color = "red", size = 1) +
    labs(title = paste("Patch:", p),
         x = "Wavelength (nm)", y = "Reflectance (%)",
         caption = "All replicates (thin lines) show within-individual variation (measurement error, SD = 2%) and between-individual variation (e.g., amplitude, peak shifts). Red line is the patch mean across all individuals.") +
    theme_minimal()
})

grid.arrange(grobs = fig6_plots, ncol = 2)
```

**Breakdown**:
- **Step 1: Filter and Average**
  - **Code**: `subset(data, Patch == p)` and `aggregate(...)`
  - **What**: Pick one patch's data (2430 rows: 5 fish × 3 replicates × 81 wavelengths), then average across all for the red line (81 rows).
  - **Structure**: `p_data` keeps all details; `mean_data` is just `Wavelength` and `Reflectance`.
  - **Illustration**: Draw a big table (all data), circle one patch's rows, then shrink it to one mean curve.
  - **Why**: Shows raw variation (thin lines) vs. the "typical" patch (red), setting up patch comparison.

- **Step 2: Plotting**
  - **Code**: `ggplot() + geom_line(...)`
  - **What**: Plot all 15 curves per patch faintly, overlay the mean in bold red.
  - **Why**: Lets us see if fish differ enough to affect patch identity.

- **Expectations**:
  - **Distinguishable**: Thin lines cluster tightly around unique red means—patch "fingerprints" hold despite fish variation.
  - **Not Distinguishable**: Thin lines sprawl widely or overlap other patches' means—too much variation blurs patch identity.

## Figure 7: Adaptive Coherence Estimator (ACE)
Can we match each fish's patch to its "typical" color?

### Equations
- **Spectral Angle (α)**: \(\alpha = \cos^{-1} \left( \frac{\mathbf{x} \cdot \mathbf{S}}{\|\mathbf{x}\| \|\mathbf{S}\|} \right)\)  
  Compares shape similarity between a fish's patch (\(\mathbf{x}\)) and the patch mean (\(\mathbf{S}\)).
- **ACE**: \(D_{ACE} = \frac{(\mathbf{S}^T \Sigma_b^{-1} \mathbf{x})^2}{(\mathbf{S}^T \Sigma_b^{-1} \mathbf{S})(\mathbf{x}^T \Sigma_b^{-1} \mathbf{x})}\)  
  Adds background variation (\(\Sigma_b\))—not used here due to small data.

```{r fig7}
mean_spectra <- data %>%
  group_by(Individual, Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), .groups = "drop") %>%
  pivot_wider(names_from = Wavelength, values_from = Mean)

patch_means <- data %>%
  group_by(Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), .groups = "drop") %>%
  pivot_wider(names_from = Wavelength, values_from = Mean)

spectral_angle <- function(x, s) {
  dot <- sum(x * s, na.rm = TRUE)
  norm_x <- sqrt(sum(x^2, na.rm = TRUE))
  norm_s <- sqrt(sum(s^2, na.rm = TRUE))
  acos(dot / (norm_x * norm_s)) * 180 / pi  # Degrees
}

ace_data <- data.frame(
  Individual = rep(unique(data$Individual), each = length(patches)),
  Patch = rep(patches, n_ind),
  Angle = numeric(n_ind * length(patches))
)

for (i in 1:nrow(ace_data)) {
  ind <- ace_data$Individual[i]
  patch <- ace_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  ace_data$Angle[i] <- spectral_angle(x, s)
}

ggplot(ace_data, aes(x = Patch, y = Individual, fill = Angle)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Spectral Angle (°)") +
  labs(title = "Figure 7: ACE Spectral Matching",
       x = "Target Patch", y = "Test Individual",
       caption = "Spectral angles between individual means and patch means. Within-individual variation is averaged per individual. Between-individual variation drives angle differences (e.g., faded individual has higher angles).") +
  theme_minimal()
```

**Breakdown**:
- **Step 1: Mean Spectra**
  - **Code**: `group_by(Individual, Patch, Wavelength) %>% summarise(...)`
  - **What**: Average 3 replicates per fish per patch (20 rows: 5 fish × 4 patches), spread wavelengths into columns.
  - **Structure**: From 9720 rows to 20 rows, each with 81 wavelength columns.
  - **Illustration**: Draw a grid—rows are fish-patch combos, columns are wavelengths.
  - **Why**: Creates \(\mathbf{x}\) (fish spectra) for the spectral angle equation.

- **Step 2: Patch Means**
  - **Code**: `group_by(Patch, Wavelength) %>% summarise(...)`
  - **What**: Average across all fish for each patch (4 rows, 81 columns).
  - **Structure**: Simplifies to \(\mathbf{S}\) (target spectra).
  - **Illustration**: Smaller grid—4 rows (patches), 81 columns.
  - **Why**: Defines the "typical" patch for comparison in \(\alpha\).

- **Step 3: Spectral Angle**
  - **Code**: `spectral_angle <- function(x, s) {...}`
  - **What**: Compute angle between \(\mathbf{x}\) and \(\mathbf{S}\) using dot product and norms.
  - **Illustration**: Sketch two arrows (spectra), measure angle between them—small angle = similar shape.
  - **Why**: Core of ACE—tests if fish patches match their "typical" shape (Eq. 1).

- **Step 4: Plotting**
  - **Code**: `ggplot(...) + geom_tile(...)`
  - **What**: Heatmap—angles per fish per patch, colored by size.
  - **Why**: Shows match quality—low angles mean good fits.

- **Expectations**:
  - **Distinguishable**: Low angles within patches, high angles between—clear patch "clubs."
  - **Not Distinguishable**: Angles similar across patches—fish don't match "typical" uniquely.

## Alternative Methods for Patch Differentiation
Let's try other ways to spot patch differences!

### Figure 8: Euclidean Distance
How far apart are the "fingerprints" in total distance?

```{r alt1-euclidean}
euclidean_dist <- function(x, s) {
  sqrt(sum((x - s)^2, na.rm = TRUE))
}

euclid_data <- ace_data  # Reuse structure
for (i in 1:nrow(euclid_data)) {
  ind <- euclid_data$Individual[i]
  patch <- euclid_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  euclid_data$Angle[i] <- euclidean_dist(x, s)  # Rename 'Angle' to 'Distance'
}
colnames(euclid_data)[3] <- "Distance"

ggplot(euclid_data, aes(x = Patch, y = Individual, fill = Distance)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Euclidean Distance") +
  labs(title = "Figure 8: Euclidean Distance Analysis",
       x = "Target Patch", y = "Test Individual",
       caption = "Euclidean distance between individual means and patch means. Within-individual variation is averaged; between-individual variation (e.g., fading) increases distance.") +
  theme_minimal()
```

**Breakdown**:
- **Step 1: Distance Calculation**
  - **Code**: `euclidean_dist <- function(x, s) {...}`
  - **What**: Subtract fish spectrum (\(\mathbf{x}\)) from patch mean (\(\mathbf{S}\)), square, sum, square root.
  - **Structure**: Same as `ace_data` (20 rows), replaces angle with distance.
  - **Illustration**: Draw two points in space, connect with a line—length is distance.
  - **Why**: Unlike spectral angle (shape only), this includes brightness differences.

- **Step 2: Plotting**
  - **Code**: `ggplot(...)`
  - **What**: Heatmap of distances.
  - **Why**: Visualizes total difference—bigger numbers mean less "typical."

- **Expectations**:
  - **Distinguishable**: High distances between patches, low within—patch "zones" separate.
  - **Not Distinguishable**: Distances overlap—patches blend together.

### Figure 9: Principal Component Analysis (PCA)
Can we squeeze spectra into a simpler picture?

```{r alt2-pca}
spectra_matrix <- mean_spectra[, -(1:2)] %>% as.matrix()
pca_result <- prcomp(spectra_matrix, scale. = TRUE)
pca_data <- as.data.frame(pca_result$x) %>%
  mutate(Individual = mean_spectra$Individual, Patch = mean_spectra$Patch)

ggplot(pca_data, aes(x = PC1, y = PC2, color = Patch, shape = Individual)) +
  geom_point(size = 3) +
  labs(title = "Figure 9: PCA of Spectral Signatures",
       x = "PC1", y = "PC2",
       caption = "PCA on mean spectra per patch per individual. Within-individual variation is averaged; between-individual and within-fish patch differences drive separation.") +
  theme_minimal()
```

**Breakdown**:
- **Step 1: PCA**
  - **Code**: `prcomp(spectra_matrix, scale. = TRUE)`
  - **What**: Turn 81-band spectra into a few key directions (PC1, PC2) capturing most variation.
  - **Structure**: From 20 rows × 81 columns to 20 rows × 2 (PC1, PC2), plus labels.
  - **Illustration**: Draw a cloud of 81-D points, project onto a 2-D plane—dots spread out.
  - **Why**: Simplifies comparison—no equation like \(\alpha\), just visual clustering.

- **Step 2: Plotting**
  - **Code**: `ggplot(...) + geom_point(...)`
  - **What**: Scatter plot—PC1 vs. PC2, colored by patch, shaped by fish.
  - **Why**: Shows if patches form distinct groups.

- **Expectations**:
  - **Distinguishable**: Tight, separate clusters per patch—colors don't mix.
  - **Not Distinguishable**: Overlapping clusters—patches look alike.

### Figure 10: Mahalanobis Distance
How far are patches, considering their "spread"?

```{r alt3-mahalanobis}
mahalanobis_dist <- function(x, mean_vec, cov_mat, lambda = 0.1) {
  # Add regularization to covariance matrix
  n <- nrow(cov_mat)
  regularized_cov <- cov_mat + lambda * diag(n)
  diff <- x - mean_vec
  sqrt(t(diff) %*% solve(regularized_cov) %*% diff)
}

mahal_data <- ace_data
cov_mat <- cov(spectra_matrix)  # Covariance of all spectra
for (i in 1:nrow(mahal_data)) {
  ind <- mahal_data$Individual[i]
  patch <- mahal_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  mahal_data$Angle[i] <- mahalanobis_dist(x, s, cov_mat)
}
colnames(mahal_data)[3] <- "Distance"

ggplot(mahal_data, aes(x = Patch, y = Individual, fill = Distance)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Mahalanobis Distance") +
  labs(title = "Figure 10: Mahalanobis Distance Analysis",
       x = "Target Patch", y = "Test Individual",
       caption = "Mahalanobis distance between individual means and patch means, using regularized covariance. Within-individual variation is averaged; between-individual variation affects distances.") +
  theme_minimal()
```

**Breakdown**:
- **Step 1: Distance Calculation**
  - **Code**: `mahalanobis_dist <- function(...)`
  - **What**: Adjusts Euclidean distance by covariance (like a "stretchy" ruler), regularized to avoid errors with small data.
  - **Structure**: 20 rows, distance column.
  - **Illustration**: Draw an oval (covariance shape), measure distance from center—stretches with data spread.
  - **Why**: Like ACE, considers how spectra vary together, not just point-to-point.

- **Step 2: Plotting**
  - **Code**: `ggplot(...)`
  - **What**: Heatmap of adjusted distances.
  - **Why**: Shows "unusualness" relative to typical patch spread.

- **Expectations**:
  - **Distinguishable**: High distances between patches, low within—unique "zones."
  - **Not Distinguishable**: Similar distances—patches too close in "stretched" space.

### Figure 11: Statistical Tests
Are patches really different within each fish? Let's test it!

```{r patch-stats}
# Create all possible patch pairs
patch_pairs <- combn(patches, 2, paste, collapse = " vs. ")

# Calculate angles between all patch pairs for each individual
angle_data <- data.frame()
for (ind in unique(data$Individual)) {
  for (i in 1:(length(patches)-1)) {
    for (j in (i+1):length(patches)) {
      x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patches[i], -(1:2)])
      s <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patches[j], -(1:2)])
      angle <- spectral_angle(x, s)
      angle_data <- rbind(angle_data, 
                         data.frame(Individual = ind,
                                  Patch_Pair = paste(patches[i], "vs.", patches[j]),
                                  Angle = angle))
    }
  }
}

# Kruskal-Wallis test (non-parametric)
kw_test <- kruskal.test(Angle ~ Patch_Pair, data = angle_data)
print(kw_test)

# Pairwise Wilcoxon tests
pairwise <- pairwise.wilcox.test(angle_data$Angle, angle_data$Patch_Pair, p.adjust.method = "BH")
print(pairwise)

ggplot(angle_data, aes(x = Patch_Pair, y = Angle)) +
  geom_boxplot() +
  labs(title = "Figure 11: Spectral Angles Between Patch Pairs",
       x = "Patch Pair", y = "Spectral Angle (°)",
       caption = "Boxplots of spectral angles between patch pairs within individuals. Kruskal-Wallis test assesses overall differences; pairwise p-values indicate specific distinctions.") +
  theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**Breakdown**:
- **Step 1: Pairwise Angles**
  - **Code**: `for (ind in ...) {... spectral_angle(x, s) ...}`
  - **What**: For each fish, compare all patch pairs (e.g., White vs. Black) using spectral angle.
  - **Structure**: 30 rows (5 fish × 6 pairs), columns: `Individual`, `Patch_Pair`, `Angle`.
  - **Illustration**: List fish, draw lines between patch pairs, label with angles.
  - **Why**: Spectral angle (Eq. 1) tests shape similarity within fish—our core question.

- **Step 2: Statistical Tests**
  - **Code**: `kruskal.test(...)` and `pairwise.wilcox.test(...)`
  - **What**: Kruskal-Wallis checks if pair angles differ overall; Wilcoxon compares each pair (BH adjusts for multiple tests).
  - **Why**: Tells us if patches are statistically unique (p < 0.05 = different).

- **Step 3: Plotting**
  - **Code**: `ggplot(...) + geom_boxplot(...)`
  - **What**: Boxplot of angles per pair.
  - **Why**: Visualizes spread—tight boxes with big gaps mean distinct patches.

- **Expectations**:
  - **Distinguishable**: High angles, low p-values (e.g., < 0.05) for most pairs—patches stand apart.
  - **Not Distinguishable**: Low angles, high p-values—pairs overlap, no clear winners.

## Notes for Undergrads

- **Visual Aids**: Encourage sketching:
  - Figure 3: Four curves with shaded bands.
  - Figure 5: Slopes on those curves.
  - Figure 6: Spaghetti lines per patch, red mean.
  - Figures 7-10: Heatmaps—color intensity as "difference."
  - Figure 11: Boxes with whiskers for pairs.
- **Key Takeaway**: We're hunting for patch "fingerprints" within fish. Big differences (angles, distances) and small p-values mean we can tell White from Blue, etc. Small differences mean they're too alike.
- **Why Structures Matter**: Long data (9720 rows) lets us zoom in/out; means (20 or 4 rows) simplify for equations like \(\alpha\) or distance—each step builds our detective case!