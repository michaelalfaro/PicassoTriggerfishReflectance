---
title: "Picasso Triggerfish Reflectance Analysis Demo"
author: "Grok (xAI)"
date: "March 20, 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(signal)  # For derivatives
library(hyperSpec)  # For spectral angle (simplified ACE)
```

## Overview
This demo analyzes simulated reflectance data for four color patches (White, Black, Orange, Blue) in Picasso triggerfish (*Rhinecanthus aculeatus*) across 400-800 nm for five individuals with three repeated measures per patch. It replicates figures from Kolmann et al. (2021)—Figures 3, 5, 6, and 7—and explains the use of Equations 1 and 2 for spectral angle analysis. The data includes measurement error (SD = 2%), inter-individual variation (±10% amplitude, ±20 nm peak shift), and one faded individual (30% reduced reflectance) to test detection.

## Data Simulation
The reflectance data was simulated with biologically realistic curves:
- **White**: Structural, high reflectance (~70-90%) with a broad peak at 500 nm.
- **Black**: Pigmented, low reflectance (~10%) across all wavelengths.
- **Orange**: Pigmented, peak at 620 nm (~90%).
- **Blue**: Pigmented, peak at 470 nm (~85%).

## Load Data
```{r load-data}
data <- read.csv("Picasso_Triggerfish_Reflectance.csv")
patches <- unique(data$Patch)  # Define patches variable
n_ind <- length(unique(data$Individual))  # Define number of individuals
head(data)
```

The dataset includes columns: `Individual`, `Patch`, `Replicate`, `Wavelength`, and `Reflectance`.

## Figure 3: Comparative Spectral Signatures
```{r fig3}
fig3_data <- data %>%
  group_by(Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), SD = sd(Reflectance), .groups = "drop")

ggplot(fig3_data, aes(x = Wavelength, y = Mean, color = Patch)) +
  geom_line() +
  geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), alpha = 0.2, linetype = 0) +
  labs(title = "Figure 3: Comparative Spectral Signatures",
       x = "Wavelength (nm)", y = "Reflectance (%)",
       caption = "Mean reflectance per patch across all individuals and replicates. Within-patch variation (measurement error and individual differences) is captured by SD bands. Between-individual variation is averaged out.") +
  theme_minimal()
```

**Legend**: This figure shows the mean reflectance profile for each patch, averaging across all individuals and their three replicates. Within-patch variation includes measurement error (SD = 2% per replicate) and between-individual differences (e.g., amplitude and peak shifts), visualized as standard deviation (SD) bands. Between-individual variation is collapsed into the mean, highlighting patch-specific spectral shapes.

## Figure 5: First Derivatives
```{r fig5}
fig5_data <- fig3_data %>%
  group_by(Patch) %>%
  arrange(Wavelength) %>%
  mutate(Deriv = c(NA, diff(Mean) / diff(Wavelength)[1])) %>%
  ungroup()

ggplot(fig5_data, aes(x = Wavelength, y = Deriv, color = Patch)) +
  geom_line() +
  labs(title = "Figure 5: First Derivative of Spectral Signatures",
       x = "Wavelength (nm)", y = "dR/dλ",
       caption = "First derivative of mean reflectance per patch. Within-patch variation is averaged, focusing on rate of change across wavelengths. Between-individual variation is not shown as it's collapsed into the mean.") +
  theme_minimal()
```

**Legend**: The first derivative of mean reflectance per patch highlights regions of rapid change. Within-patch variation (replicate error and individual differences) is averaged into the mean reflectance before differentiation, so this figure focuses on patch-specific trends rather than individual-level variation. Between-individual differences are not directly visible, as the derivative is computed from the aggregated mean.

## Figure 6: Intraspecific Variation
```{r fig6}
fig6_plots <- lapply(patches, function(p) {
  p_data <- subset(data, Patch == p)
  mean_data <- aggregate(Reflectance ~ Wavelength, data = p_data, FUN = mean)
  
  ggplot() +
    geom_line(data = p_data, 
              aes(x = Wavelength, y = Reflectance, group = interaction(Individual, Replicate)),
              alpha = 0.3) +
    geom_line(data = mean_data,
              aes(x = Wavelength, y = Reflectance),
              color = "red", size = 1) +
    labs(title = paste("Patch:", p),
         x = "Wavelength (nm)", y = "Reflectance (%)",
         caption = "All replicates (thin lines) show within-individual variation (measurement error, SD = 2%) and between-individual variation (e.g., amplitude, peak shifts). Red line is the patch mean across all individuals.") +
    theme_minimal()
})

grid.arrange(grobs = fig6_plots, ncol = 2)
```

**Legend**: Each panel displays reflectance curves for a single patch across all individuals and replicates (thin lines), with the mean in red. Within-individual variation is the spread among the three replicates per individual (measurement error, SD = 2%). Between-individual variation is evident in differences in amplitude and peak positions across individuals (e.g., one faded individual has lower reflectance). Within-patch variation combines both, captured by the spread of all lines, while the red mean averages across individuals to show the typical patch profile.

## Figure 7: Adaptive Coherence Estimator (ACE)
### Equations
Kolmann et al. (2021) use ACE for spectral matching, with two key equations:

- **Equation 1: Spectral Angle (α)**  
  Measures similarity between test spectrum \(\mathbf{x}\) (individual mean) and target spectrum \(\mathbf{S}\) (patch mean):
  \[
  \alpha = \cos^{-1} \left( \frac{\mathbf{x} \cdot \mathbf{S}}{\|\mathbf{x}\| \|\mathbf{S}\|} \right)
  \]
  Where \(\mathbf{x} \cdot \mathbf{S}\) is the dot product, and \(\|\mathbf{x}\|\) and \(\|\mathbf{S}\|\) are Euclidean norms. Lower angles indicate greater similarity.

- **Equation 2: ACE Detection Statistic**  
  Incorporates background covariance \(\Sigma_b\):
  \[
  D_{ACE} = \frac{(\mathbf{S}^T \Sigma_b^{-1} \mathbf{x})^2}{(\mathbf{S}^T \Sigma_b^{-1} \mathbf{S})(\mathbf{x}^T \Sigma_b^{-1} \mathbf{x})}
  \]
  Values closer to 1 indicate a match, accounting for background variability.

### Analysis
We calculate spectral angles between each individual's mean spectrum and the overall mean per patch, simplifying ACE by omitting \(\Sigma_b\).

```{r fig7}
mean_spectra <- data %>%
  group_by(Individual, Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), .groups = "drop") %>%
  pivot_wider(names_from = Wavelength, values_from = Mean)

patch_means <- data %>%
  group_by(Patch, Wavelength) %>%
  summarise(Mean = mean(Reflectance), .groups = "drop") %>%
  pivot_wider(names_from = Wavelength, values_from = Mean)

spectral_angle <- function(x, s) {
  dot <- sum(x * s, na.rm = TRUE)
  norm_x <- sqrt(sum(x^2, na.rm = TRUE))
  norm_s <- sqrt(sum(s^2, na.rm = TRUE))
  acos(dot / (norm_x * norm_s)) * 180 / pi  # Degrees
}

ace_data <- data.frame(
  Individual = rep(unique(data$Individual), each = length(patches)),
  Patch = rep(patches, n_ind),
  Angle = numeric(n_ind * length(patches))
)

for (i in 1:nrow(ace_data)) {
  ind <- ace_data$Individual[i]
  patch <- ace_data$Patch[i]
  x <- as.numeric(mean_spectra[mean_spectra$Individual == ind & mean_spectra$Patch == patch, -(1:2)])
  s <- as.numeric(patch_means[patch_means$Patch == patch, -1])
  ace_data$Angle[i] <- spectral_angle(x, s)
}

ggplot(ace_data, aes(x = Patch, y = Individual, fill = Angle)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red", name = "Spectral Angle (°)") +
  labs(title = "Figure 7: ACE Spectral Matching",
       x = "Target Patch", y = "Test Individual",
       caption = "Spectral angles between individual means and patch means. Within-individual variation is averaged per individual. Between-individual variation drives angle differences (e.g., faded individual has higher angles).") +
  theme_minimal()
```

### Detailed ACE Explanation
- **How ACE Uses Spectral Angle**: In Kolmann et al. (2021), ACE matches a test spectrum (\(\mathbf{x}\)) to a known target (\(\mathbf{S}\)) by considering both similarity (via spectral angle, Eq. 1) and background variability (via \(\Sigma_b\), Eq. 2). The spectral angle measures the cosine similarity between vectors, ignoring amplitude differences and focusing on shape. Equation 2 adjusts this by weighting against background covariance, enhancing detection in noisy data.
- **Simplifications**: Here, we use only Equation 1 (spectral angle) due to the small dataset (5 individuals, 4 patches). Calculating \(\Sigma_b\) (background covariance) requires a larger sample to be meaningful, so we omit Equation 2's full ACE statistic. This simplification assumes the patch mean (\(\mathbf{S}\)) is the target, and individual deviations (e.g., fading) increase the angle. For real data with more samples, \(\Sigma_b\) would be computed from all non-target spectra to improve specificity.
- **Does ACE Work Here?**: Yes, but with caveats. With only 5 individuals and 20 spectra (5 × 4 patches), the dataset is small for full ACE (which thrives on larger, noisier datasets). The spectral angle alone effectively highlights variation (e.g., the faded individual), but lacks the robustness of \(\Sigma_b\)-adjusted ACE. For your real data, with potentially more individuals, full ACE would be feasible and more powerful.

## Interpretation
- **Figure 3**: Patch-specific profiles average out within- and between-individual variation, with SD showing combined spread.
- **Figure 5**: Derivatives focus on mean patch trends, masking individual variation.
- **Figure 6**: Explicitly shows within-individual (replicate spread) and between-individual (curve differences) variation, with the mean as a reference.
- **Figure 7**: Spectral angles capture between-individual variation relative to patch means, with within-individual variation averaged out. The faded individual should have higher angles.

This template is ready for your real data—replace the CSV and adjust as needed.
